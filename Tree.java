import java.util.Random;
import java.util.*;

/*A Tree class that will construct a random Tree object, which will in turn act as an 
 * individual in our population.
 * 
 * Author: Ashley Alexander-Lee (so far)
 * */

public class Tree {

 private Node myRoot;
 
 /*Constructs a random tree according to user specifications.
  * 
  * Parameters:
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  */
 public Tree(String[] funcSet, String[] termSet, int maxDepth, String method){
  
  //go ahead and choose random operator for the root
  //a tree must at least have a root node
  myRoot = new Node(getRandomData(funcSet), null, null); 
  
  //generate random tree
  generateRandomTree(myRoot, funcSet, 
  termSet, maxDepth - 1, method); //maxDepth - 1 because the root is level 1
  
 }
 
 public Tree(Node root){
   myRoot = root; 
   
 }
 
 /*Takes a String[] and returns a random element from the array. 
  * 
  * Parameters:
  *   dataSet - the String[] from which we need to pull a random element
  * Return:
  *   a String that is the random element 
  */
 private static String getRandomData(String[] dataSet) {
  Random rand = new Random();
     int randIndex = rand.nextInt(dataSet.length);
     return dataSet[randIndex];
 }
 
 /*A method that concatenates two arrays.
  * 
  * Parameters:
  *   array1, array2 - the String[]s that need to be concatenated
  * Return:
  *   concatenated - a String[] that contains all of the elements 
  *   from array1 and array2
  */
 private String[] mergeArrays(String[] array1, String[] array2){ //must be a better way to do this
    String[] concatenated = new String[array1.length + array2.length];
    
    for (int i = 0; i < array1.length; i++){
     concatenated[i] = array1[i];
    }
    for (int j = array1.length; j < array1.length + array2.length; j++){
     concatenated[j] = array2[j - array1.length];
    }
       return concatenated;
 }
 
 /*Generates a random tree according to the parameters passed into our constructor.
  * (with the assumption that the user will use the ramped half-and-half method)
  * 
  * Parameters:
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  */
 private void generateRandomTree(Node curNode, String[] funcSet, 
   String[] termSet, int maxDepth, String method){
  
  if (method == "full"){      //run the Full Tree method
   generateFullTree(curNode, funcSet, 
   termSet, maxDepth);
  }else{                      //else run the grow tree method
   //combine two arrays: funcSet and termSet - pass in as dataSet
   String[] dataSet = mergeArrays(funcSet, termSet);
   generateGrowTree(curNode, dataSet, termSet, maxDepth);
  }
  
 }
 
 /*Returns true if the string is a digit, false if not.
  * 
  * Parameter:
  *   str - a String
  * Return:
  *   a boolean that indicates whether the String is a digit
  */
 private boolean stringIsDigit(String str){
  boolean isStr = true;
  for (int i = 0; i < str.length(); i++){
   if (Character.isDigit(str.charAt(i))){
    isStr= true;
   }
   else{
    return false;
   }
  }
  return isStr;
 }
 
 /*Generates a random tree according to the grow method.
  * 
  * Parameters:
  *   curNode - a Node currently being visited
  *   dataSet - a String[] that contains all possible operators and numbers/variables
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  * */
 private void generateGrowTree(Node curNode, String[] dataSet, String[] termSet, int maxDepth) {
  Node curLeft;
  Node curRight;
  if (maxDepth < 1 && !stringIsDigit(curNode.getData())){
   //add nodes as leaves if there aren't already leaves at the max Depth
   curLeft = new Node(getRandomData(termSet), null, null); 
   curRight = new Node(getRandomData(termSet), null, null);
   
   curNode.setLeft(curLeft);
   curNode.setRight(curRight);
   
   return;
  }
  else if (!stringIsDigit(curNode.getData())){
   //if the node does not contain a number (i.e. if the node
   //is not a leaf), add left and right nodes with random values
   curLeft = new Node(getRandomData(dataSet), null, null);
   curRight = new Node(getRandomData(dataSet), null, null);
   
   curNode.setLeft(curLeft);
   curNode.setRight(curRight);
   
   generateGrowTree(curLeft, dataSet, termSet, maxDepth-1);
   generateGrowTree(curRight, dataSet, termSet, maxDepth-1);
  }
  else{
   //if the node is a leaf, there should be no more children
   return;
  }
  
 }

 /*Generates a random tree using the full tree method.
  * 
  * Parameters:
  *   curNode - a Node currently being visited
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  * */
 private void generateFullTree(Node curNode, String[] funcSet,
   String[] termSet, int maxDepth) {
  Node curLeft;
  Node curRight;
  if (maxDepth < 1){
   //add nodes as leaves once at max depth
   curLeft = new Node(getRandomData(termSet), null, null);
   curRight = new Node(getRandomData(termSet), null, null);
   
   curNode.setLeft(curLeft);
   curNode.setRight(curRight);
   
   return;
  }else{
   //add left and right nodes that contain operators
   curLeft = new Node(getRandomData(funcSet), null, null);
   curRight = new Node(getRandomData(funcSet), null, null);
   
   curNode.setLeft(curLeft);
   curNode.setRight(curRight);
   
   generateFullTree(curLeft, funcSet, termSet, maxDepth-1);
   generateFullTree(curRight, funcSet, termSet, maxDepth-1);
  } 
 }

 /*private Node findReplacePosPar(Node curNode, Node replacePos){
   if (curNode.getLeft().equals(replacePos)){
    System.out.println(curNode.getLeft().getNum() + " is the same as " + replacePos.getNum());
    return curNode;
   }
   if (curNode.getRight().equals(replacePos)){
    return curNode;
   }
  
  if (curNode.getLeft() != null){
   findReplacePosPar(curNode.getLeft(), replacePos);
  }
  if (curNode.getRight() != null){
   findReplacePosPar(curNode.getRight(), replacePos);
  }
  
  return null;
 }
 public Tree(Tree tree1, Tree tree2, Node replacePos){
  Node parent = findReplacePosPar(tree1.getRoot(), replacePos);
  if (parent == null){
   System.out.println("Problem");
  }
  if (parent.getLeft().equals(replacePos)){
   parent.setLeft(tree2.getRoot());
  }
  else{
   parent.setRight(tree2.getRoot());
  }
 }
 
 
 

 */
 
 
 //prints tree in preorder traversal
 public void printPostOrder(){
   post(myRoot);
 }
 //printPostOrder helper
 public void post(Node node){
   if (node == null) return;
   post(node.getLeft());
   post(node.getRight());
   System.out.print(node.getData() + " ");
 }
 
 //two given two operands and one operator, performs operation. Returns -1 if operand isn't found
 private double operate(double first, double second, String op){
   if (op.equals("+")){
     return first + second;
   }
   if (op.equals("-")){
     return first - second;
   }
   if (op.equals("*")){
     return first * second;
   }
   if (op.equals("/")){
     return first / second;
   }
   return -1;
   
   
 }
 
 
 
 //computes Y values given x value and tree function
 public double getY(double x){
   LinkedList<Double> nums = new LinkedList<Double>();
   getY(myRoot,nums,x);
   return nums.remove();
 }
 //getY helper
 //uses postorder traversal to make computations
 private void getY(Node node, LinkedList<Double> nums, double x){
     if (node == null) return;
     getY(node.getLeft(),nums,x);
     getY(node.getRight(),nums,x);
     String data = node.getData();
     
     if (stringIsDigit(data)){
       
       nums.add((double) Integer.parseInt(data));
       
     }
     else if (data.equals("X")){
       nums.add((double) x);
     }
     else {
       double last = nums.removeLast();
       double secondToLast = nums.removeLast();
       nums.add(operate(secondToLast, last, data));
     }
     
     
 }
 
 
 private void strHelper(Node curNode, String space){
  
  if (curNode == null){
   return;
  }
  String data = curNode.getData();
  System.out.println(space + data);
  strHelper(curNode.getLeft(), space + "  |");
  strHelper(curNode.getRight(), space + "  |");
 }
 
 public void str(){
  strHelper(myRoot, "");
 }
 
 

 public Node getRoot(){
  return myRoot;
 }
 

 public boolean equals(Object obj){
   if (!(obj instanceof Tree)){
            return false;
   }
   if (obj == this){
       return true;
   }
   return equalsHelper(((Tree) obj).getRoot(), myRoot);
   
 }
 
 
 //return copy of tree
 public Tree treeCopy(){
   return new Tree(treeCopy(myRoot));
 }
 
 //treeCopy helper
 public Node treeCopy(Node node){
    if (node == null) return null;
    Node copy = new Node(node.getData());
    copy.setLeft(treeCopy(node.getLeft()));
    copy.setRight(treeCopy(node.getRight()));
    return copy;
    
 }
 
 //gets crossover point of a tree. type determines if point is a terminal node or a function node. Chooses node using a uniform probability
 public Node getCross(String type){
    List<Node> nodes = new ArrayList<Node>();
    getNodes(nodes,type, myRoot);
    double[] distribution = new double[nodes.size()];
    double sectionSize = 1.0 / distribution.length;
    //creates probability array. Each node has equal chance of being chosen
    for (int i = 1; i <= distribution.length; i++){
       distribution[i - 1] = i * sectionSize;
    }
    double r = new Random().nextDouble();
    for (int i = 0; i < distribution.length; i++){
      if (r < distribution[i]){
        return nodes.get(i);
      }
    }
    return null;
    
   
 }
 
 //get nodes helper
 private void getNodes(List<Node> nodes, String type, Node node){
    if (node == null) return;
    if (stringIsDigit(node.getData()) && type == "terminal"){
      nodes.add(node);
    }
    if (!stringIsDigit(node.getData()) && type == "function"){
      nodes.add(node);
    }
    getNodes(nodes, type, node.getLeft());
    getNodes(nodes, type, node.getRight());
   
 }
 
 
 
 //equals helper
 private boolean equalsHelper(Node other, Node thisNode){
   if (other == null && thisNode == null) return true;
   if ((other == null && thisNode != null) || (other != null && thisNode == null) || other.getData() != thisNode.getData()){
     return false;
   }
   
   return (equalsHelper(other.getLeft(), thisNode.getLeft()) && equalsHelper(other.getRight(), thisNode.getRight()));
   
 }
 
 
}
 
