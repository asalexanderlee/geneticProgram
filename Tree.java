import java.util.Random;
import java.util.Stack;

/*A Tree class that will construct a random Tree object, which will in turn act as an 
 * individual in our population.
 * 
 * Author: Ashley Alexander-Lee (so far)
 * */

public class Tree {

	private Node myRoot;
	private int mySize;
	
	/*Constructs a random tree according to user specifications.
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	public Tree(String[] funcSet, String[] termSet, int maxDepth, String method){
		
		//go ahead and choose random operator for the root
		//a tree must at least have a root node
		myRoot = new Node(getRandomData(funcSet), null, null); 
		mySize = 1;
		
		//generate random tree
		generateRandomTree(myRoot, funcSet, 
		termSet, maxDepth - 1, method); //maxDepth - 1 because the root is level 1
		
	}
	
	/*Takes a String[] and returns a random element from the array. 
	 * 
	 * Parameters:
	 * 		dataSet - the String[] from which we need to pull a random element
	 * Return:
	 * 		a String that is the random element 
	 */
	private static String getRandomData(String[] dataSet) {
		Random rand = new Random();
	    int randIndex = rand.nextInt(dataSet.length);
	    return dataSet[randIndex];
	}
	
	/*A method that concatenates two arrays.
	 * 
	 * Parameters:
	 * 		array1, array2 - the String[]s that need to be concatenated
	 * Return:
	 * 		concatenated - a String[] that contains all of the elements 
	 * 		from array1 and array2
	 */
	private String[] mergeArrays(String[] array1, String[] array2){ //must be a better way to do this
		  String[] concatenated = new String[array1.length + array2.length];
		  
		  for (int i = 0; i < array1.length; i++){
			  concatenated[i] = array1[i];
		  }
		  for (int j = array1.length; j < array1.length + array2.length; j++){
			  concatenated[j] = array2[j - array1.length];
		  }
	      return concatenated;
	}
	
	/*Generates a random tree according to the parameters passed into our constructor.
	 * (with the assumption that the user will use the ramped half-and-half method)
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	private void generateRandomTree(Node curNode, String[] funcSet, 
			String[] termSet, int maxDepth, String method){
		
		if (method == "full"){ 					//run the Full Tree method
			generateFullTree(curNode, funcSet, 
			termSet, maxDepth);
		}else{                 					//else run the grow tree method
			//combine two arrays: funcSet and termSet - pass in as dataSet
			String[] dataSet = mergeArrays(funcSet, termSet);
			generateGrowTree(curNode, dataSet, termSet, maxDepth);
		}
		
	}
	
	/*Returns true if the string is a digit, false if not.
	 * 
	 * Parameter:
	 * 		str - a String
	 * Return:
	 * 		a boolean that indicates whether the String is a digit
	 */
	private boolean stringIsDigit(String str){
		boolean isStr = true;
		for (int i = 0; i < str.length(); i++){
			if (Character.isDigit(str.charAt(i))){
				isStr= true;
			}
			else{
				return false;
			}
		}
		return isStr;
	}
	
	/*Generates a random tree according to the grow method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		dataSet - a String[] that contains all possible operators and numbers/variables
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	private void generateGrowTree(Node curNode, String[] dataSet, String[] termSet, int maxDepth) {
		Node curLeft;
		Node curRight;
		if (maxDepth < 1 && !stringIsDigit(curNode.getData())){
			//add nodes as leaves if there aren't already leaves at the max Depth
			curLeft = new Node(getRandomData(termSet), null, null); 
			curRight = new Node(getRandomData(termSet), null, null);
			mySize = mySize + 2;
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			return;
		}
		else if (!stringIsDigit(curNode.getData())){
			//if the node does not contain a number (i.e. if the node
			//is not a leaf), add left and right nodes with random values
			curLeft = new Node(getRandomData(dataSet), null, null);
			curRight = new Node(getRandomData(dataSet), null, null);
			
			mySize = mySize + 2;
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			generateGrowTree(curLeft, dataSet, termSet, maxDepth-1);
			generateGrowTree(curRight, dataSet, termSet, maxDepth-1);
		}
		else{
			//if the node is a leaf, there should be no more children
			return;
		}
		
	}

	/*Generates a random tree using the full tree method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	private void generateFullTree(Node curNode, String[] funcSet,
			String[] termSet, int maxDepth) {
		Node curLeft;
		Node curRight;
		if (maxDepth < 1){
			//add nodes as leaves once at max depth
			curLeft = new Node(getRandomData(termSet), null, null);
			curRight = new Node(getRandomData(termSet), null, null);
			
			mySize = mySize + 2;
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			return;
		}else{
			//add left and right nodes that contain operators
			curLeft = new Node(getRandomData(funcSet), null, null);
			curRight = new Node(getRandomData(funcSet), null, null);
			
			mySize = mySize + 2;
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			generateFullTree(curLeft, funcSet, termSet, maxDepth-1);
			generateFullTree(curRight, funcSet, termSet, maxDepth-1);
		}	
	}
	
	/*Returns a random node in the current tree.
	 * 
	 * Parameters:
	 * 		root - a Node representing the root
	 * 		point - the placement of the random node 
	 * Return:
	 * 		ans - the random Node we wish to change
	 */
	private Node findPoint(Node root, int point){
		if (point == 0){
			return root;
		}
		Stack<Node> curNodes = new Stack<Node>();
		curNodes.push(root);
		boolean found = false;
		Node ans = null;
		
		while (!found){
			
			int curSize = curNodes.size();
			for (int i = 0; i < curSize; i++){
				if (point == 0){
					ans = curNodes.pop();
					found = true;
				}else{
					Node poppedNode = curNodes.pop();
					if (point == 1){
						ans = poppedNode.getLeft();
					}
					else if (poppedNode.getLeft() != null){
						curNodes.push(poppedNode.getLeft());
						point--;
					}
					if (poppedNode.getRight() != null){
						curNodes.push(poppedNode.getRight());
						point--;
					}
				}
			}
		}
		
		return ans;
	}
	
	/*Mutates a random node in the current tree by replacing a number/variable with
	 * a number/variable or an operator with an operator
	 * 
	 * Parameters:
	 * 		termSet - a String[] containing the possible terminal data
	 * 		funcSet - a String[] containing the possible operators
	 */
	public void mutate(String[] termSet, String[] funcSet){
		Random rand = new Random();
		int randNum = rand.nextInt(mySize);
		Node randNode = findPoint(myRoot, randNum);
		if (stringIsDigit(randNode.getData())){
			randNode.setData(getRandomData(termSet));
		}else{
			randNode.setData(getRandomData(funcSet));
		}
	}
	
	private void strHelper(Node curNode, String space){
		
		if (curNode == null){
			return;
		}
		String data = curNode.getData();
		System.out.println(space + data);
		strHelper(curNode.getLeft(), space + "  |");
		strHelper(curNode.getRight(), space + "  |");
	}
	
	public void str(){
		strHelper(myRoot, "");
	}
	
	

	public Node getRoot(){
		return myRoot;
	}
}
