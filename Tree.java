import java.util.*;

/*A Tree class that will construct a random Tree object, which will in turn act as an 
 * individual in our population.
 * 
 * Author: Ashley Alexander-Lee (so far)
 * */

public class Tree {


	private Node myRoot;
	private int mySize;
	
	/*Constructs a random tree according to user specifications.
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	public Tree(String[] funcSet, String[] termSet, int maxDepth, String method){
		
		//go ahead and choose random operator for the root
		//a tree must at least have a root node
		myRoot = new Node(funcSet[new Random().nextInt(funcSet.length)]);
		mySize = 1;
		
		//generate random tree
		generateRandomTree(myRoot, funcSet, 
		termSet, maxDepth - 1, method); //maxDepth - 1 because the root is level 1
		
	}
	
	public Tree(Node root){
		myRoot = root;
		mySize = 1;
	}
	
	/*Takes a String[] and returns a random element from the array. 
	 * 
	 * Parameters:
	 * 		dataSet - the String[] from which we need to pull a random element
	 * Return:
	 * 		a String that is the random element 
	 */
	private static String getRandomData(String[] funcSet, String[] termSet) {
		 Random rand1 = new Random();
		 double randDouble = rand1.nextDouble();
		 if (randDouble < 0.4){
			 Random rand = new Random();
		     int randIndex = rand.nextInt(funcSet.length);
		     return funcSet[randIndex]; 
		 }
		 else if (randDouble >= 0.4 && randDouble < 0.8){
		     return "x"; 
		 }
		 if (randDouble >= 0.8){
			 Random rand = new Random();
		     int randIndex = rand.nextInt(termSet.length);
		     return termSet[randIndex]; 
		 }
		 return null;
	 }
	 
	
	/*A method that concatenates two arrays.
	 * 
	 * Parameters:
	 * 		array1, array2 - the String[]s that need to be concatenated
	 * Return:
	 * 		concatenated - a String[] that contains all of the elements 
	 * 		from array1 and array2
	 */
	private String[] mergeArrays(String[] array1, String[] array2){ //must be a better way to do this
		  String[] concatenated = new String[array1.length + array2.length];
		  
		  for (int i = 0; i < array1.length; i++){
			  concatenated[i] = array1[i];
		  }
		  for (int j = array1.length; j < array1.length + array2.length; j++){
			  concatenated[j] = array2[j - array1.length];
		  }
	      return concatenated;
	}
	
	/*Generates a random tree according to the parameters passed into our constructor.
	 * (with the assumption that the user will use the ramped half-and-half method)
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	private void generateRandomTree(Node curNode, String[] funcSet, 
			String[] termSet, int maxDepth, String method){
		
		if (method == "full"){ 					//run the Full Tree method
			generateFullTree(curNode, funcSet, 
			termSet, maxDepth);
		}else{                 					//else run the grow tree method
			//combine two arrays: funcSet and termSet - pass in as dataSet
			String[] dataSet = mergeArrays(funcSet, termSet);
			generateGrowTree(curNode, dataSet, termSet, maxDepth);
		}
		
	}
	
	private boolean stringIsLetter(String str){
		   if(Character.isLetter(str.charAt(0))){
			   System.out.println(str + " is a letter");
			 return true;
		   }
		  return false;
	}
	
	/*Returns true if the string is a digit, false if not.
	 * 
	 * Parameter:
	 * 		str - a String
	 * Return:
	 * 		a boolean that indicates whether the String is a digit
	 */
	private boolean stringIsDigit(String str){
		boolean isStr = true;
		for (int i = 0; i < str.length(); i++){
			if (Character.isDigit(str.charAt(i))){
				isStr= true;
			}
			else{
				return false;
			}
		}
		return isStr;
	}
	
	/*Generates a random tree according to the grow method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		dataSet - a String[] that contains all possible operators and numbers/variables
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	private void generateGrowTree(Node curNode, String[] funcSet, String[] termSet, int maxDepth) {
		  Node curLeft;
		  Node curRight;
		  if (maxDepth < 1 && !stringIsDigit(curNode.getData()) && !stringIsLetter(curNode.getData())){
		   //add nodes as leaves if there aren't already leaves at the max Depth
		   curLeft = new Node(getRandomData(funcSet, termSet), null, null); 
		   curRight = new Node(getRandomData(funcSet, termSet), null, null);
		   mySize += 2;
		   curNode.setLeft(curLeft);
		   curNode.setRight(curRight);
		   
		   return;
		  }
		  else if (!stringIsDigit(curNode.getData()) && !stringIsLetter(curNode.getData())){
		   //if the node does not contain a number (i.e. if the node
		   //is not a leaf), add left and right nodes with random values
		   curLeft = new Node(getRandomData(funcSet,termSet), null, null);
		   curRight = new Node(getRandomData(funcSet,termSet), null, null);
		   
		   curNode.setLeft(curLeft);
		   curNode.setRight(curRight);
		   mySize += 2;
		   generateGrowTree(curLeft, funcSet, termSet, maxDepth-1);
		   generateGrowTree(curRight, funcSet, termSet, maxDepth-1);
		  }
		  else{
		   //if the node is a leaf, there should be no more children
		   return;
		  }
		  
		 }

	/*Generates a random tree using the full tree method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	 private void generateFullTree(Node curNode, String[] funcSet,
			   String[] termSet, int maxDepth) {
			  Node curLeft;
			  Node curRight;
			  if (maxDepth < 1){
			   //add nodes as leaves once at max depth
			   if ((new Random()).nextDouble() < 0.4) curLeft = new Node(termSet[new Random().nextInt(termSet.length)]);
			   else { curLeft = new Node("x");}
			   
			   if ((new Random()).nextDouble() < 0.4) curRight = new Node(termSet[new Random().nextInt(termSet.length)]);
			   else { curRight = new Node("x");}
			   mySize += 2;
			   curNode.setLeft(curLeft);
			   curNode.setRight(curRight);
			   
			   return;
			  }else{
			   //add left and right nodes that contain operators
			   curLeft = new Node(funcSet[new Random().nextInt(funcSet.length)]);
			   curRight = new Node(funcSet[new Random().nextInt(funcSet.length)]);
			   
			   curNode.setLeft(curLeft);
			   curNode.setRight(curRight);
			   mySize +=2;
			   generateFullTree(curLeft, funcSet, termSet, maxDepth-1);
			   generateFullTree(curRight, funcSet, termSet, maxDepth-1);
			  } 
			 }
	
	/*Returns a random node in the current tree.
	 * 
	 * Parameters:
	 * 		root - a Node representing the root
	 * 		point - the placement of the random node 
	 * Return:
	 * 		ans - the random Node we wish to change
	 */
	private Node findPoint(Node root, int point){
		if (point == 0){
			return root;
		}
		Stack<Node> curNodes = new Stack<Node>();
		curNodes.push(root);
		boolean found = false;
		Node ans = null;
		
		while (!found){
			
			int curSize = curNodes.size();
			for (int i = 0; i < curSize; i++){
				if (point == 0){
					ans = curNodes.pop();
					found = true;
				}else{
					Node poppedNode = curNodes.pop();
					if (point == 1){
						ans = poppedNode.getLeft();
					}
					else if (poppedNode.getLeft() != null){
						curNodes.push(poppedNode.getLeft());
						point--;
					}
					if (poppedNode.getRight() != null){
						curNodes.push(poppedNode.getRight());
						point--;
					}
				}
			}
		}
		
		return ans;
	}
	
	/*Mutates a random node in the current tree by replacing a number/variable with
	 * a number/variable or an operator with an operator
	 * 
	 * Parameters:
	 * 		termSet - a String[] containing the possible terminal data
	 * 		funcSet - a String[] containing the possible operators
	 */
	public void mutate(String[] termSet, String[] funcSet){
		Random rand = new Random();
		int randNum = rand.nextInt(mySize);
		Node randNode = findPoint(myRoot, randNum);
		if (stringIsDigit(randNode.getData())){
			randNode.setData((new Random()).nextDouble() < 0.4 ? termSet[new Random().nextInt(termSet.length)] : "x");
		}else{
			randNode.setData(funcSet[new Random().nextInt(funcSet.length)]);
		}
	}
	
  //prints tree in preorder traversal
 public void printPostOrder(){
   post(myRoot);
 }
 //printPostOrder helper
 public void post(Node node){
   if (node == null) return;
   post(node.getLeft());
   post(node.getRight());
   System.out.print(node.getData() + " ");
 }
 
 //two given two operands and one operator, performs operation. Returns -1 if operand isn't found
 private double operate(double first, double second, String op){
   if (op.equals("+")){
     return first + second;
   }
   if (op.equals("-")){
     return first - second;
   }
   if (op.equals("*")){
     return first * second;
   }
   if (op.equals("/")){
     return first / second;
   }
   return -1;
   
   
 }
 
 
 
 //computes Y values given x value and tree function
 public double getY(double x){
   LinkedList<Double> nums = new LinkedList<Double>();
   getY(myRoot,nums,x);
   return nums.remove();
 }
 //getY helper
 //uses postorder traversal to make computations
 private void getY(Node node, LinkedList<Double> nums, double x){
     if (node == null) return;
     getY(node.getLeft(),nums,x);
     getY(node.getRight(),nums,x);
     String data = node.getData();
     
     if (stringIsDigit(data)){
       
       nums.add((double) Integer.parseInt(data));
       
     }
     else if (data.equals("x")){
    	System.out.println((double) x);
       nums.add((double) x);
     }
     else {
       System.out.println(data);
       double last = nums.removeLast();
       double secondToLast = nums.removeLast();
       nums.add(operate(secondToLast, last, data));
     }
     
     
 }
	private void strHelper(Node curNode, String space){
		
		if (curNode == null){
			return;
		}
		String data = curNode.getData();
		System.out.println(space + data);
		strHelper(curNode.getLeft(), space + "  |");
		strHelper(curNode.getRight(), space + "  |");
	}
	
	public void str(){
		strHelper(myRoot, "");
	}
	


 public Node getRoot(){
  return myRoot;
 }
 

 public boolean equals(Object obj){
   if (!(obj instanceof Tree)){
            return false;
   }
   if (obj == this){
       return true;
   }
   return equalsHelper(((Tree) obj).getRoot(), myRoot);
   
 }
 
 
 //return copy of tree
 public Tree treeCopy(){
   return new Tree(treeCopy(myRoot));
 }
 
 //treeCopy helper
 public Node treeCopy(Node node){
    if (node == null) return null;
    Node copy = new Node(node.getData());
    copy.setLeft(treeCopy(node.getLeft()));
    copy.setRight(treeCopy(node.getRight()));
    return copy;
    
 }
 
 //gets crossover point of a tree. type determines if point is a terminal node or a function node. Chooses node using a uniform probability
 public Node getCross(String type){
    List<Node> nodes = new ArrayList<Node>();
    getNodes(nodes,type, myRoot);
    double[] distribution = new double[nodes.size()];
    double sectionSize = 1.0 / distribution.length;
    //creates probability array. Each node has equal chance of being chosen
    for (int i = 1; i <= distribution.length; i++){
       distribution[i - 1] = i * sectionSize;
    }
    double r = new Random().nextDouble();
    for (int i = 0; i < distribution.length; i++){
      if (r < distribution[i]){
        return nodes.get(i);
      }
    }
    return null;
    
   
 }
 
 //get nodes helper
 private void getNodes(List<Node> nodes, String type, Node node){
    if (node == null) return;
    if (stringIsDigit(node.getData()) && type == "terminal"){
      nodes.add(node);
    }
    if (!stringIsDigit(node.getData()) && type == "function"){
      nodes.add(node);
    }
    getNodes(nodes, type, node.getLeft());
    getNodes(nodes, type, node.getRight());
   
 }
 
 
 
 //equals helper
 private boolean equalsHelper(Node other, Node thisNode){
   if (other == null && thisNode == null) return true;
   if ((other == null && thisNode != null) || (other != null && thisNode == null) || other.getData() != thisNode.getData()){
     return false;
   }
   
   return (equalsHelper(other.getLeft(), thisNode.getLeft()) && equalsHelper(other.getRight(), thisNode.getRight()));
   
 }
 
 
}
 
