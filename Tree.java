import java.util.Random;

/*A Tree class that will construct a random Tree object, which will in turn act as an 
 * individual in our population.
 * 
 * Author: Ashley Alexander-Lee (so far)
 * */

public class Tree {

	private Node myRoot;
	
	/*Constructs a random tree according to user specifications.
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	public Tree(String[] funcSet, String[] termSet, int maxDepth, String method){
		
		//go ahead and choose random operator for the root
		//a tree must at least have a root node
		myRoot = new Node(getRandomData(funcSet), null, null); 
		
		//generate random tree
		generateRandomTree(myRoot, funcSet, 
		termSet, maxDepth - 1, method); //maxDepth - 1 because the root is level 1
		
	}
	
	/*Takes a String[] and returns a random element from the array. 
	 * 
	 * Parameters:
	 * 		dataSet - the String[] from which we need to pull a random element
	 * Return:
	 * 		a String that is the random element 
	 */
	private static String getRandomData(String[] dataSet) {
		Random rand = new Random();
	    int randIndex = rand.nextInt(dataSet.length);
	    return dataSet[randIndex];
	}
	
	/*A method that concatenates two arrays.
	 * 
	 * Parameters:
	 * 		array1, array2 - the String[]s that need to be concatenated
	 * Return:
	 * 		concatenated - a String[] that contains all of the elements 
	 * 		from array1 and array2
	 */
	private String[] mergeArrays(String[] array1, String[] array2){ //must be a better way to do this
		  String[] concatenated = new String[array1.length + array2.length];
		  
		  for (int i = 0; i < array1.length; i++){
			  concatenated[i] = array1[i];
		  }
		  for (int j = array1.length; j < array1.length + array2.length; j++){
			  concatenated[j] = array2[j - array1.length];
		  }
	      return concatenated;
	}
	
	/*Generates a random tree according to the parameters passed into our constructor.
	 * (with the assumption that the user will use the ramped half-and-half method)
	 * 
	 * Parameters:
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 */
	private void generateRandomTree(Node curNode, String[] funcSet, 
			String[] termSet, int maxDepth, String method){
		
		if (method == "full"){ 					//run the Full Tree method
			generateFullTree(curNode, funcSet, 
			termSet, maxDepth);
		}else{                 					//else run the grow tree method
			//combine two arrays: funcSet and termSet - pass in as dataSet
			String[] dataSet = mergeArrays(funcSet, termSet);
			generateGrowTree(curNode, dataSet, termSet, maxDepth);
		}
		
	}
	
	/*Returns true if the string is a digit, false if not.
	 * 
	 * Parameter:
	 * 		str - a String
	 * Return:
	 * 		a boolean that indicates whether the String is a digit
	 */
	private boolean stringIsDigit(String str){
		boolean isStr = true;
		for (int i = 0; i < str.length(); i++){
			if (Character.isDigit(str.charAt(i))){
				isStr= true;
			}
			else{
				return false;
			}
		}
		return isStr;
	}
	
	/*Generates a random tree according to the grow method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		dataSet - a String[] that contains all possible operators and numbers/variables
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	private void generateGrowTree(Node curNode, String[] dataSet, String[] termSet, int maxDepth) {
		Node curLeft;
		Node curRight;
		if (maxDepth < 1 && !stringIsDigit(curNode.getData())){
			//add nodes as leaves if there aren't already leaves at the max Depth
			curLeft = new Node(getRandomData(termSet), null, null); 
			curRight = new Node(getRandomData(termSet), null, null);
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			return;
		}
		else if (!stringIsDigit(curNode.getData())){
			//if the node does not contain a number (i.e. if the node
			//is not a leaf), add left and right nodes with random values
			curLeft = new Node(getRandomData(dataSet), null, null);
			curRight = new Node(getRandomData(dataSet), null, null);
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			generateGrowTree(curLeft, dataSet, termSet, maxDepth-1);
			generateGrowTree(curRight, dataSet, termSet, maxDepth-1);
		}
		else{
			//if the node is a leaf, there should be no more children
			return;
		}
		
	}

	/*Generates a random tree using the full tree method.
	 * 
	 * Parameters:
	 * 		curNode - a Node currently being visited
	 * 		funcSet - a String[] that contains all possible operators
	 * 		termSet - a String[] that contains all possible integers/doubles/variables
	 * 		maxDepth - an int representing the max height of the tree
	 * 		method - a String that denotes "full" for a random tree generated by the full
	 * 				method and "grow" for a random tree generated by the grow method.
	 * */
	private void generateFullTree(Node curNode, String[] funcSet,
			String[] termSet, int maxDepth) {
		Node curLeft;
		Node curRight;
		if (maxDepth < 1){
			//add nodes as leaves once at max depth
			curLeft = new Node(getRandomData(termSet), null, null);
			curRight = new Node(getRandomData(termSet), null, null);
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			return;
		}else{
			//add left and right nodes that contain operators
			curLeft = new Node(getRandomData(funcSet), null, null);
			curRight = new Node(getRandomData(funcSet), null, null);
			
			curNode.setLeft(curLeft);
			curNode.setRight(curRight);
			
			generateFullTree(curLeft, funcSet, termSet, maxDepth-1);
			generateFullTree(curRight, funcSet, termSet, maxDepth-1);
		}	
	}

	/*private Node findReplacePosPar(Node curNode, Node replacePos){
			if (curNode.getLeft().equals(replacePos)){
				System.out.println(curNode.getLeft().getNum() + " is the same as " + replacePos.getNum());
				return curNode;
			}
			if (curNode.getRight().equals(replacePos)){
				return curNode;
			}
		
		if (curNode.getLeft() != null){
			findReplacePosPar(curNode.getLeft(), replacePos);
		}
		if (curNode.getRight() != null){
			findReplacePosPar(curNode.getRight(), replacePos);
		}
		
		return null;
	}
	public Tree(Tree tree1, Tree tree2, Node replacePos){
		Node parent = findReplacePosPar(tree1.getRoot(), replacePos);
		if (parent == null){
			System.out.println("Problem");
		}
		if (parent.getLeft().equals(replacePos)){
			parent.setLeft(tree2.getRoot());
		}
		else{
			parent.setRight(tree2.getRoot());
		}
	}
	

	*/private void strHelper(Node curNode, String space){
		
		if (curNode == null){
			return;
		}
		String data = curNode.getData();
		System.out.println(space + data);
		strHelper(curNode.getLeft(), space + "  |");
		strHelper(curNode.getRight(), space + "  |");
	}
	
	public void str(){
		strHelper(myRoot, "");
	}
	
	

	public Node getRoot(){
		return myRoot;
	}
}
