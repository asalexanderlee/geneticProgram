import java.util.*;

/*A Tree class that will construct a random Tree object, which will in turn act as an 
 * individual in our population.
 * 
 * Author: Ashley Alexander-Lee (so far)
 * */

public class Tree {


 private Node myRoot;
 private int mySize;
 
 /*Constructs a random tree according to user specifications.
  * 
  * Parameters:
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  */
 public Tree(String[] funcSet, String[] termSet, int maxDepth, String method){
  
  //go ahead and choose random operator for the root
  //a tree must at least have a root node
  myRoot = new Node(funcSet[new Random().nextInt(funcSet.length)]);
  mySize = 1;
  
  //generate random tree
  generateRandomTree(myRoot, funcSet, 
  termSet, maxDepth - 1, method); //maxDepth - 1 because the root is level 1
  
 }
 
 public Tree(Node root){
  myRoot = root;
  mySize = 1;
 }
 
 /*Takes a String[] and returns a random element from the array. 
  * 
  * Parameters:
  *   dataSet - the String[] from which we need to pull a random element
  * Return:
  *   a String that is the random element 
  */
 private static String getRandomData(String[] funcSet, String[] termSet) {
   Random rand1 = new Random();
   double randDouble = rand1.nextDouble();
   if (randDouble < 0.4){
    Random rand = new Random();
       int randIndex = rand.nextInt(funcSet.length);
       return funcSet[randIndex]; 
   }
   else if (randDouble >= 0.4 && randDouble < 0.8){
       return "x"; 
   }
   if (randDouble >= 0.8){
    Random rand = new Random();
       int randIndex = rand.nextInt(termSet.length);
       return termSet[randIndex]; 
   }
   return null;
  }
  
 
 /*A method that concatenates two arrays.
  * 
  * Parameters:
  *   array1, array2 - the String[]s that need to be concatenated
  * Return:
  *   concatenated - a String[] that contains all of the elements 
  *   from array1 and array2
  */
 private String[] mergeArrays(String[] array1, String[] array2){ //must be a better way to do this
    String[] concatenated = new String[array1.length + array2.length];
    
    for (int i = 0; i < array1.length; i++){
     concatenated[i] = array1[i];
    }
    for (int j = array1.length; j < array1.length + array2.length; j++){
     concatenated[j] = array2[j - array1.length];
    }
       return concatenated;
 }
 
 /*Generates a random tree according to the parameters passed into our constructor.
  * (with the assumption that the user will use the ramped half-and-half method)
  * 
  * Parameters:
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  */
 private void generateRandomTree(Node curNode, String[] funcSet, 
   String[] termSet, int maxDepth, String method){
  
  if (method == "full"){      //run the Full Tree method
   generateFullTree(curNode, funcSet, 
   termSet, maxDepth);
  }else{                      //else run the grow tree method
   //combine two arrays: funcSet and termSet - pass in as dataSet
   String[] dataSet = mergeArrays(funcSet, termSet);
   generateGrowTree(curNode, dataSet, termSet, maxDepth);
  }
  
 }
 
 private boolean stringIsLetter(String str){
     if(Character.isLetter(str.charAt(0))){
      //System.out.println(str + " is a letter");
    return true;
     }
    return false;
 }
 
 /*Returns true if the string is a digit, false if not.
  * 
  * Parameter:
  *   str - a String
  * Return:
  *   a boolean that indicates whether the String is a digit
  */
 private boolean stringIsDigit(String str){
  boolean isStr = true;
  int j = 0;
  if (str.charAt(0) == '-' && str.length() > 1){
    j++;
  }
  for (int i = j; i < str.length(); i++){
   if (Character.isDigit(str.charAt(i))){
    isStr= true;
   }
   else{
    return false;
   }
  }
  return isStr;
 }
 
 /*Generates a random tree according to the grow method.
  * 
  * Parameters:
  *   curNode - a Node currently being visited
  *   dataSet - a String[] that contains all possible operators and numbers/variables
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  * */
 private void generateGrowTree(Node curNode, String[] funcSet, String[] termSet, int maxDepth) {
    Node curLeft;
    Node curRight;
    if (maxDepth < 1 && !stringIsDigit(curNode.getData()) && !stringIsLetter(curNode.getData())){
     //add nodes as leaves if there aren't already leaves at the max Depth
     curLeft = new Node(getRandomData(funcSet, termSet), null, null); 
     curRight = new Node(getRandomData(funcSet, termSet), null, null);
     mySize += 2;
     curNode.setLeft(curLeft);
     curNode.setRight(curRight);
     
     return;
    }
    else if (!stringIsDigit(curNode.getData()) && !stringIsLetter(curNode.getData())){
     //if the node does not contain a number (i.e. if the node
     //is not a leaf), add left and right nodes with random values
     curLeft = new Node(getRandomData(funcSet,termSet), null, null);
     curRight = new Node(getRandomData(funcSet,termSet), null, null);
     
     curNode.setLeft(curLeft);
     curNode.setRight(curRight);
     mySize += 2;
     generateGrowTree(curLeft, funcSet, termSet, maxDepth-1);
     generateGrowTree(curRight, funcSet, termSet, maxDepth-1);
    }
    else{
     //if the node is a leaf, there should be no more children
     return;
    }
    
   }

 /*Generates a random tree using the full tree method.
  * 
  * Parameters:
  *   curNode - a Node currently being visited
  *   funcSet - a String[] that contains all possible operators
  *   termSet - a String[] that contains all possible integers/doubles/variables
  *   maxDepth - an int representing the max height of the tree
  *   method - a String that denotes "full" for a random tree generated by the full
  *     method and "grow" for a random tree generated by the grow method.
  * */
  private void generateFullTree(Node curNode, String[] funcSet,
      String[] termSet, int maxDepth) {
     Node curLeft;
     Node curRight;
     if (maxDepth < 1){
      //add nodes as leaves once at max depth
      if ((new Random()).nextDouble() < 0.45) curLeft = new Node(termSet[new Random().nextInt(termSet.length)]);
      else { curLeft = new Node("x");}
      
      if ((new Random()).nextDouble() < 0.45) curRight = new Node(termSet[new Random().nextInt(termSet.length)]);
      else { curRight = new Node("x");}
      mySize += 2;
      curNode.setLeft(curLeft);
      curNode.setRight(curRight);
      
      return;
     }else{
      //add left and right nodes that contain operators
      curLeft = new Node(funcSet[new Random().nextInt(funcSet.length)]);
      curRight = new Node(funcSet[new Random().nextInt(funcSet.length)]);
      
      curNode.setLeft(curLeft);
      curNode.setRight(curRight);
      mySize +=2;
      generateFullTree(curLeft, funcSet, termSet, maxDepth-1);
      generateFullTree(curRight, funcSet, termSet, maxDepth-1);
     } 
    }
 
 /*Returns a random node in the current tree.
  * 
  * Parameters:
  *   root - a Node representing the root
  *   point - the placement of the random node 
  * Return:
  *   ans - the random Node we wish to change
  */
 private Node findPoint(Node root, int point){
  if (point == 0){
   return root;
  }
  Stack<Node> curNodes = new Stack<Node>();
  curNodes.push(root);
  boolean found = false;
  Node ans = null;
  
  while (!found){
   
   int curSize = curNodes.size();
   for (int i = 0; i < curSize; i++){
    if (point == 0){
     ans = curNodes.pop();
     found = true;
    }else{
     Node poppedNode = curNodes.pop();
     if (point == 1){
      ans = poppedNode.getLeft();
     }
     else if (poppedNode.getLeft() != null){
      curNodes.push(poppedNode.getLeft());
      point--;
     }
     if (poppedNode.getRight() != null){
      curNodes.push(poppedNode.getRight());
      point--;
     }
    }
   }
  }
  
  return ans;
 }
 
 /*Mutates a random node in the current tree by replacing a number/variable with
  * a number/variable or an operator with an operator
  * 
  * Parameters:
  *   termSet - a String[] containing the possible terminal data
  *   funcSet - a String[] containing the possible operators
  */
 public void mutate(String[] termSet, String[] funcSet){
  Random rand = new Random();
  int randNum = rand.nextInt(mySize);
  Node randNode = findPoint(myRoot, randNum);
  if (stringIsDigit(randNode.getData())){
   randNode.setData((new Random()).nextDouble() < 0.45 ? termSet[new Random().nextInt(termSet.length)] : "x");
  }else{
   randNode.setData(funcSet[new Random().nextInt(funcSet.length)]);
  }
 }
 
  //prints tree in preorder traversal
 public void printPostOrder(){
   post(myRoot);
 }
 //printPostOrder helper
 public void post(Node node){
   if (node == null) return;
   post(node.getLeft());
   post(node.getRight());
   System.out.print(node.getData() + " ");
 }
 
 //two given two operands and one operator, performs operation. Returns -1 if operand isn't found
 private double operate(double first, double second, String op){
   
   if (op.equals("+")){
     return first + second;
   }
   if (op.equals("-")){
     return first - second;
   }
   if (op.equals("*")){
     
     return first * second;
   }
   if (op.equals("/")){
     
     return first / second;
   }
   return -1;
   
   
 }
 
 
 
 //computes Y values given x value and tree function
 public double getY(double x){
   
   //this.str();
   if (myRoot.getLeft() == null || myRoot.getRight() == null){
     return stringIsDigit(myRoot.getData()) ? Integer.parseInt(myRoot.getData()) : x;
   }
   LinkedList<Double> nums = new LinkedList<Double>();
   getY(myRoot,nums,x);
   return nums.remove();
 }
 //getY helper
 //uses postorder traversal to make computations
 private void getY(Node node, LinkedList<Double> nums, double x){
     if (node == null) return;
     getY(node.getLeft(),nums,x);
     getY(node.getRight(),nums,x);
     String data = node.getData();
     
     if (stringIsDigit(data)){
       
       nums.add((double) Integer.parseInt(data));
       
     }
     else if (data.equals("x")){
     
       nums.add((double) x);
     }
     else {
       //System.out.println(Arrays.toString(nums.toArray()));
       if (nums.peekLast() == null) this.str();
       double last = nums.removeLast();
       if (nums.peekLast() == null) this.str();
        double secondToLast = nums.removeLast();
        nums.addFirst(operate(secondToLast, last, data));
       
      
     }
     
     
 }
 private void strHelper(Node curNode, String space){
  
  if (curNode == null){
   return;
  }
  String data = curNode.getData();
  System.out.println(space + data);
  strHelper(curNode.getLeft(), space + "  |");
  strHelper(curNode.getRight(), space + "  |");
 }
 
 public void str(){
  strHelper(myRoot, "");
 }
 


 public Node getRoot(){
  return myRoot;
 }
 

 public boolean equals(Object obj){
   if (!(obj instanceof Tree)){
            return false;
   }
   if (obj == this){
       return true;
   }
   return equalsHelper(((Tree) obj).getRoot(), myRoot);
   
 }
 
 
 //return copy of tree
 public Tree treeCopy(){
   return new Tree(treeCopy(myRoot));
 }
 
 //treeCopy helper
 public Node treeCopy(Node node){
    if (node == null) return null;
    Node copy = new Node(node.getData());
    copy.setLeft(treeCopy(node.getLeft()));
    copy.setRight(treeCopy(node.getRight()));
    return copy;
    
 }
 
 //gets crossover point of a tree. type determines if point is a terminal node or a function node. Chooses node using a uniform probability
 public Node getCross(String type){
    if (myRoot.getLeft() == null || myRoot.getRight() == null) return myRoot;
    List<Node> nodes = new ArrayList<Node>();
    getNodes(nodes,type, myRoot);
    double[] distribution = new double[nodes.size()];
    double sectionSize = 1.0 / distribution.length;
    //creates probability array. Each node has equal chance of being chosen
    for (int i = 1; i <= distribution.length; i++){
       distribution[i - 1] = i * sectionSize;
    }
    double r = new Random().nextDouble();
    for (int i = 0; i < distribution.length; i++){
      if (r < distribution[i]){
        return nodes.get(i);
      }
    }
    this.str();
    return null;
    
   
 }
 
 //get nodes helper
 private void getNodes(List<Node> nodes, String type, Node node){
    if (node == null) return;
    if ((stringIsDigit(node.getData()) || node.getData().equals("x")) && type.equals("terminal")){
      
      nodes.add(node);
    }
    else if (!stringIsDigit(node.getData()) && type.equals("function")){
      nodes.add(node);
    }
    
    
    
    getNodes(nodes, type, node.getLeft());
    getNodes(nodes, type, node.getRight());
   
 }
 
 
 
 //equals helper
 private boolean equalsHelper(Node other, Node thisNode){
   if (other == null && thisNode == null) return true;
   if ((other == null && thisNode != null) || (other != null && thisNode == null) || other.getData() != thisNode.getData()){
     return false;
   }
   
   return (equalsHelper(other.getLeft(), thisNode.getLeft()) && equalsHelper(other.getRight(), thisNode.getRight()));
   
 }
 
 
}
 
